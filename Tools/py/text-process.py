import os, sys, re

def show_exception_and_exit(exc_type, exc_value, tb):
	import traceback
	
	traceback.print_exception(exc_type, exc_value, tb)
	sys.exit(-1)

def getEntries(lines):
	"""takes a compiled file and returns a list of individual text entries"""
	
	result = []

	entry = ""
	textID = ""
	definition = None

	newEntry = True
	lineIndex = 0

	for line in lines:
		l = line.strip()
		lineIndex += 1

		if newEntry: # new text entry
			if l == "":
				next # Skip empty lines
			
			else:
				matchobj = re.match(r"^#\s*([0x[0-9a-fA-F]+|#)\s*(\w+)?$", l, re.M | re.I)
				
				assert matchobj, "Error at line " + str(lineIndex) + ' - "' + l + '":\nEntries must begin with the format "#0xtextID optional_definition" or "## optional_definition"'
				
				if matchobj.group(1) == '#': # if no ID given, use the previous one + 1
					textID = hex(int(textID, 16)+1)
				else:
					textID = matchobj.group(1)
				
				definition = matchobj.group(2)
				newEntry = False
		
		elif l[-3:] == "[X]": # Line ends in [X] (end of text entry)
			entry += (line + "\n")
			tmp = (entry, textID, definition)
			result.append(tmp)
			entry = ""
			definition = None
			newEntry = True
		
		else:
			entry += (line + "\n")

	return result

def preprocess(filepath, depth = 0):
	if depth > 500:
		print("Warning: #include depth exceeds 500. Check for circular inclusion.\nCurrent file: " + filepath)
		return None

	with open(filepath, 'r') as f:
		for line in f.readlines():
			m = re.match(r"^#include\s+(.+)", line.strip(), re.M | re.I)

			if m:
				includee = m.group(1).strip()

				if (includee[0] == '"'):
					includee = includee.strip('"')

				dirpath = os.path.dirname(filepath)

				if len(dirpath) > 0:
					includee = dirpath + "/" + includee

				for otherLine in preprocess(includee, depth+1):
					yield otherLine

			else:
				yield line

def main():
	sys.excepthook = show_exception_and_exit

	if len(sys.argv) != 4:
		sys.exit("Usage: `{0}` <input> <install output> <definition output>".format(sys.argv[0]))

	path     = sys.argv[1]
	datapath = sys.argv[2]
	defpath  = sys.argv[3]

	if not os.path.exists(path):
		sys.exit("`{0}` doesn't exist".format(path))

	(cwd, inputFile) = os.path.split(path)
	inputName = inputFile.split('.')[0]

	lines = preprocess(path)

	if lines:
		definitionsheader = """// Text Definitions generated by textprocess

#ifndef TEXT_DEFINITIONS
	#define TEXT_DEFINITIONS
#endif

"""
		dataheader = """// Text Data installer generated by textprocess

#include "Tools/Tool Helpers.txt"
#include "{0}"

""".format(os.path.relpath(defpath, os.path.split(datapath)[0]))

		# Generate the files

		with open(datapath, 'w') as f:
			f.write(dataheader)
			f.write("{\n\n") # Scoping labels

		with open(defpath, 'w') as f:
			f.write(definitionsheader)

		textEntries = getEntries(lines)
		subdirectory = os.path.join(cwd, ".TextEntries")

		try:
			os.mkdir(subdirectory)
		
		except Exception:
			pass
		
		for entry in textEntries: # create separate files for each text entry
			content = entry[0]
			textID = entry[1]
			definition = entry[2]

			textFileName  = os.path.join(subdirectory, inputName + "_" + textID + ".fetxt")
			textDataLabel = "_TextData" + textID

			# Write include

			with open(datapath, 'a') as f:
				f.write(textDataLabel + ":\n")
				f.write('#incbin "' + os.path.relpath(textFileName, os.path.dirname(datapath)) +'.bin"\n')
				f.write("setText(" + textID + ", " + textDataLabel + ")\n\n")

			if definition:
				with open(defpath, 'a') as f:
					f.write("#define " + definition + " " + textID + "\n")

			# Check if file exists with the same content
			# This is to prevent make to rebuild files that depend on this
			# As it would not have changed

			if os.path.exists(textFileName):
				with open(textFileName, 'r') as f:
					if str(f.read()) == content:
						continue

			# Write data

			with open(textFileName, 'w') as f:
				f.write(content)

		with open(datapath, 'a') as f:
			f.write("}\n")
	
	else:
		print("No data written to output.\n")

if __name__ == '__main__':
	main()
